# Experimental!
#         __            _   _
#  _   _ / _| ___  _ __| |_| |__
# | | | | |_ / _ \| '__| __| '_ \
# | |_| |  _| (_) | |  | |_| | | |
#  \__,_|_|  \___/|_|   \__|_| |_|
#
# Forth, in uiua!
#
# The core is _two_ dictionaries (le gasp!), which are implemented differently.
# - The first is the "internal dict", which maps words to
#   internally defined primitives through the RunPrim function.
# - The second is the "userdefs dict", is implemented as a uiua `map`
#   from word to list of integers. These integers are indices to other words,
#   their sign indicating whether they refer to a primitive (negative)
#   or to another userdef (positive).
#
# - Numbers: Since uiua works internally in just floats, I'm going to
#            simplify the system substantially by making the call that
#            all numbers are f64s. This removes an entire stack, a
#            whole suite of domain-specific functions and a lot of
#            special casing
#
# - Strings handling: mask out strings before pbbn. Take into account
#           backslashes mask _those_ out with `find $ \"`

â”Œâ”€â•´Word
  # Pre-evaluated
  |N {Num: Â°0type}    # number (f64)
  |W {Word: Â°1type}   # identifier for word
  |S {String: Â°1type} # quoted string
â””â”€â•´
â”Œâ”€â•´Val
  # Post-evaluated
  |N {Num: Â°0type}    # number (f64)
  |S {String: Â°1type} # string
â””â”€â•´

RunPrimGen! â†^ (
  â‰¡â—‡(âœÂ°â–¡(â–½Â¬âŠ¸âˆŠ" \"") Â°âŠŸ âŠœâ–¡ Â¬âŠ¸â¦· "DEFINEDAS")
  âŠƒ($"BuiltIns = _" /â—‡âŠ‚ ËœâŠ‚"}" âˆ§(ËœâŠ‚$"\"_\" ") âŠ™"{"
  | /â—‡âŠ‚ âšËœ$"| â©(_) Â°(Word~W\"_\")"
    âŠ‚"â£(â©(âŠ‚Val~N) Â°(Word~N)"
    ËœâŠ‚ $ | â¤$"Cannot run string: _" âŠ™0 Â°(Word~S)
    ËœâŠ‚ $ | â¤$"Unrecognized word: _" âŠ™0 Â°(Word~W)
    ËœâŠ‚")"
    $"RunPrim = _"
  )
  $"_\n_"
)

RunPrimGen!(
  "+" DEFINEDAS âŠ‚ âœâˆ©Â°Val~N+ Â°âŠŸ âŠƒâ†™â†˜2
| "-" DEFINEDAS âŠ‚ âœâˆ©Â°Val~N- Â°âŠŸ âŠƒâ†™â†˜2
| "*" DEFINEDAS âŠ‚ âœâˆ©Â°Val~NÃ— Â°âŠŸ âŠƒâ†™â†˜2
| "/" DEFINEDAS âŠ‚ âœâˆ©Â°Val~NÃ· Â°âŠŸ âŠƒâ†™â†˜2
| "dup" DEFINEDAS âŠ‚âŠ‚. âŠƒâ†™â†˜1
| "rot" DEFINEDAS âŠ‚â†»â‚ âŠƒâ†™â†˜3
| "-rot" DEFINEDAS âŠ‚â†»â‚‹â‚ âŠƒâ†™â†˜3
| "print" DEFINEDAS &p â£(Â°Val~N|Â°Val~S) âŠƒâŠ¢â†˜â‚)

# Userdefs Stack ? Word Userdefs Stack
EvalWord â† |3.2 (
  â£(âŠ¸get Â°Word~W # Run userdef
    â©(âˆ§(â¨¬(ğ„âŒRunPrim Word~WÂ°â–¡ËœâŠBuiltIns|â—‡EvalWord)>â‚€âŠƒÂ±âŒµ))
  | â©(ğ„âŒRunPrim))
)
# Userdefs Stack ? Words Userdefs Stack
Eval â† âŠ™âŠ™â‹…â—Œ â¢(âŠ“EvalWord+â‚ â—¡â‹…â‹…âŠ¡|â‹…â‹…(>âŠ™â§»)) â¤šâ‹…âŠ™âŠ™0

# TODO: Parse strings
Parse â† âŠœ(â£(Word~N â‹•|Word~W))Â¬âŠ¸âˆŠ" \n" # Words ? Input

EmptyStack â† â†¯0_2 []

Eval Parse "3 5 SQUARE +" map {"SQUARE"} [Â¯[âŠ— â–¡"dup" BuiltIns âŠ— â–¡"*" BuiltIns]] EmptyStack
