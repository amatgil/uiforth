# Experimental!
#         __            _   _
#  _   _ / _| ___  _ __| |_| |__
# | | | | |_ / _ \| '__| __| '_ \
# | |_| |  _| (_) | |  | |_| | | |
#  \__,_|_|  \___/|_|   \__|_| |_|
#
# Forth, in uiua!
#
# The core is _two_ dictionaries (le gasp!), which are implemented differently.
# - The first is the "internal dict", which maps words to
#   internally defined primitives through the RunPrimitive function.
# - The second is the "userdefs dict", is implemented as a uiua `map`
#   from word to list of integers. These integers are indices to other words,
#   their sign indicating whether they refer to a primitive (negative)
#   or to another userdef (positive).

# - Numbers: Since uiua works internally in just floats, I'm going to
#            simplify the system substantially by making the call that
#            all numbers are f64s. This removes an entire stack, a
#            whole suite of domain-specific functions and a lot of
#            special casing
#
# - Strings handling: mask out strings before pbbn. Take into account
#           backslashes mask _those_ out with `find $ \"`

â”Œâ”€â•´Word
  |N {Num: Â°0type}    # number (f64)
  |W {Word: Â°1type}   # identifier for word
  |S {String: Â°1type} # quoted string
â””â”€â•´
â”Œâ”€â•´Val
  |N {Num: Â°0type}    # number (f64)
  |S {String: Â°1type} # string
â””â”€â•´

# Stack ? Word Stack
RunPrimitive â† |2 â£(
  â©(âŠ‚Val~N) Â°(Word~N)
| â©(âŠ‚ âœâˆ©Â°Val~N+ Â°âŠŸ âŠƒâ†™â†˜2) Â°(Word~W"+") # Primitive nÂº 0
| â©(âŠ‚ âœâˆ©Â°Val~N- Â°âŠŸ âŠƒâ†™â†˜2) Â°(Word~W"-") # Primitive nÂº 1
| â©(âŠ‚ âœâˆ©Â°Val~NÃ— Â°âŠŸ âŠƒâ†™â†˜2) Â°(Word~W"*") # etc.
| â©(âŠ‚ âœâˆ©Â°Val~NÃ· Â°âŠŸ âŠƒâ†™â†˜2) Â°(Word~W"/")
| â©(âŠ‚âŠ‚. âŠƒâ†™â†˜1) Â°(Word~W"dup")
| â©(âŠ‚â†»â‚ âŠƒâ†™â†˜3) Â°(Word~W"rot")
| â©(âŠ‚â†»â‚‹â‚ âŠƒâ†™â†˜3) Â°(Word~W"-rot")
  # | â©(â¨¬(id| â¢(â†˜__1|  ) ) â‰1 Â°(Word~N) ) Â°(Word~W"if")
| â©(&p â£(Â°Val~N|Â°Val~S) âŠƒâŠ¢â†˜â‚) Â°(Word~W"print")
| â¤$"Cannot run string: _" âŠ™0 Â°(Word~S)
| â¤$"Unrecognized word: _" âŠ™0 Â°(Word~W))

BuiltIns â† {Word!(W"+" W"-" W"*" W"/" W"dup" W"rot" W"-rot" W"print")}

# Userdefs Stack ? Word Userdefs Stack
EvalWord â† |3.2 (
  â£(?âŠ¸get Â°Word~W # Run userdef
    â©(âˆ§(â¨¬(ğ„âŒRunPrimitive?Â°â–¡ËœâŠBuiltIns|â—‡EvalWord?)>â‚€âŠƒÂ±âŒµ ?)?)
  | ğ„âŒRunPrimitive)
)
# Userdefs Stack ? Words Userdefs Stack
Eval â† â‹…â—Œâ¢(âŠ™+â‚ âŠƒ(â‹…â‹…âŠ™âŠ™|âŠ™âŠ™â‹…â‹…) EvalWord âŠƒ(âŠ™â‹…â‹…âŠ™âŠ™|â‹…âŠ™âŠ™â‹…â‹…) â—¡ËœâŠ¡|<â§») âŠ™0

# Words ? Input
Parse â† âŠœ(â£(Word~N â‹•|Word~W))Â¬âŠ¸âˆŠ" \n" # TODO: Parse strings

EmptyStack â† â†¯0_2 []

# Eval Parse "10 12 + 100 +" [] EmptyStack
# Eval Parse "10 dup dup dup print" [] EmptyStack
# : SQUARE dup * ;

Eval ? Parse "3 2 SQUARE" map {"SQUARE"} [[Â¯4 Â¯2]] EmptyStack
# Eval [Word!(N 10 N 12 W "+" N 100 W "+")] [] EmptyStack
